<?php

declare(strict_types=1);

namespace App\Services;

/**
 * Vulnerability Scanner and Penetration Testing Service
 * 
 * Provides automated security testing capabilities:
 * - SQL injection detection
 * - XSS vulnerability scanning
 * - CSRF token validation
 * - Authentication bypass tests
 * - Authorization flaw detection
 * - File upload vulnerability tests
 * - Security header validation
 * - Dependency vulnerability scanning
 */
class VulnerabilityScanner
{
    private LoggerService $logger;
    private CacheService $cache;
    
    // Scan configuration
    private const SCAN_TIMEOUT = 300; // 5 minutes
    private const MAX_PAYLOAD_SIZE = 1024; // 1KB
    private const SCAN_DELAY = 100; // 100ms between requests
    
    // Risk levels
    private const RISK_CRITICAL = 'CRITICAL';
    private const RISK_HIGH = 'HIGH';
    private const RISK_MEDIUM = 'MEDIUM';
    private const RISK_LOW = 'LOW';
    private const RISK_INFO = 'INFORMATIONAL';

    public function __construct(LoggerService $logger, CacheService $cache)
    {
        $this->logger = $logger;
        $this->cache = $cache;
    }

    /**
     * Run comprehensive security scan
     */
    public function runComprehensiveScan(array $targets = [], array $options = []): array
    {
        $scanId = $this->generateScanId();
        $startTime = microtime(true);

        try {
            $this->logger->logSecurityEvent('vulnerability_scan_started', [
                'scan_id' => $scanId,
                'targets' => $targets,
                'options' => $options
            ]);

            $results = [
                'scan_id' => $scanId,
                'started_at' => date('Y-m-d H:i:s'),
                'targets' => $targets,
                'vulnerabilities' => [],
                'summary' => [
                    'total_tests' => 0,
                    'vulnerabilities_found' => 0,
                    'critical' => 0,
                    'high' => 0,
                    'medium' => 0,
                    'low' => 0,
                    'informational' => 0
                ],
                'scan_duration' => 0,
                'status' => 'IN_PROGRESS'
            ];

            // If no targets specified, scan current application
            if (empty($targets)) {
                $targets = $this->getDefaultScanTargets();
            }

            // Run different vulnerability tests
            $testSuites = [
                'sql_injection' => $this->scanSqlInjection($targets, $options),
                'xss_vulnerabilities' => $this->scanXssVulnerabilities($targets, $options),
                'csrf_protection' => $this->scanCsrfProtection($targets, $options),
                'authentication_flaws' => $this->scanAuthenticationFlaws($targets, $options),
                'authorization_bypass' => $this->scanAuthorizationBypass($targets, $options),
                'file_upload_flaws' => $this->scanFileUploadFlaws($targets, $options),
                'security_headers' => $this->scanSecurityHeaders($targets, $options),
                'sensitive_data_exposure' => $this->scanSensitiveDataExposure($targets, $options),
                'server_configuration' => $this->scanServerConfiguration($targets, $options),
                'dependency_vulnerabilities' => $this->scanDependencyVulnerabilities($options)
            ];

            // Aggregate results
            foreach ($testSuites as $suiteName => $suiteResults) {
                $results['vulnerabilities'][$suiteName] = $suiteResults['vulnerabilities'];
                $results['summary']['total_tests'] += $suiteResults['tests_run'];
                
                foreach ($suiteResults['vulnerabilities'] as $vulnerability) {
                    $results['summary']['vulnerabilities_found']++;
                    $results['summary'][strtolower($vulnerability['risk_level'])]++;
                }
            }

            $results['scan_duration'] = microtime(true) - $startTime;
            $results['completed_at'] = date('Y-m-d H:i:s');
            $results['status'] = 'COMPLETED';

            // Store scan results
            $this->storeScanResults($scanId, $results);

            $this->logger->logSecurityEvent('vulnerability_scan_completed', [
                'scan_id' => $scanId,
                'vulnerabilities_found' => $results['summary']['vulnerabilities_found'],
                'scan_duration' => $results['scan_duration']
            ]);

            return $results;

        } catch (\Exception $e) {
            $this->logger->logError('Vulnerability scan error', [
                'scan_id' => $scanId,
                'error' => $e->getMessage(),
                'targets' => $targets
            ]);

            return [
                'scan_id' => $scanId,
                'status' => 'ERROR',
                'error' => 'Vulnerability scan failed: ' . $e->getMessage(),
                'scan_duration' => microtime(true) - $startTime
            ];
        }
    }

    /**
     * SQL Injection vulnerability scanning
     */
    private function scanSqlInjection(array $targets, array $options): array
    {
        $vulnerabilities = [];
        $testsRun = 0;

        $sqlPayloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "' UNION SELECT NULL--",
            "'; DROP TABLE users--",
            "' AND (SELECT COUNT(*) FROM information_schema.tables)>0--",
            "' OR (SELECT substring(@@version,1,1))='5'--"
        ];

        foreach ($targets as $target) {
            if (!$this->isFormEndpoint($target)) {
                continue;
            }

            foreach ($sqlPayloads as $payload) {
                $testsRun++;
                
                $response = $this->sendTestRequest($target, ['test_input' => $payload]);
                
                if ($this->detectSqlInjectionVulnerability($response, $payload)) {
                    $vulnerabilities[] = [
                        'type' => 'SQL_INJECTION',
                        'target' => $target,
                        'payload' => $payload,
                        'risk_level' => self::RISK_CRITICAL,
                        'description' => 'SQL injection vulnerability detected',
                        'evidence' => $this->extractSqlInjectionEvidence($response),
                        'recommendation' => 'Use parameterized queries and input validation',
                        'cwe_id' => 'CWE-89'
                    ];
                }

                usleep(self::SCAN_DELAY * 1000); // Rate limiting
            }
        }

        return [
            'vulnerabilities' => $vulnerabilities,
            'tests_run' => $testsRun
        ];
    }

    /**
     * XSS vulnerability scanning
     */
    private function scanXssVulnerabilities(array $targets, array $options): array
    {
        $vulnerabilities = [];
        $testsRun = 0;

        $xssPayloads = [
            '<script>alert("XSS")</script>',
            '<img src=x onerror=alert("XSS")>',
            'javascript:alert("XSS")',
            '<svg onload=alert("XSS")>',
            '"><script>alert("XSS")</script>',
            "';alert('XSS');//"
        ];

        foreach ($targets as $target) {
            foreach ($xssPayloads as $payload) {
                $testsRun++;
                
                $response = $this->sendTestRequest($target, ['test_input' => $payload]);
                
                if ($this->detectXssVulnerability($response, $payload)) {
                    $riskLevel = $this->determineXssRiskLevel($target, $payload);
                    
                    $vulnerabilities[] = [
                        'type' => 'XSS',
                        'target' => $target,
                        'payload' => $payload,
                        'risk_level' => $riskLevel,
                        'description' => 'Cross-site scripting vulnerability detected',
                        'evidence' => $this->extractXssEvidence($response),
                        'recommendation' => 'Implement proper output encoding and CSP headers',
                        'cwe_id' => 'CWE-79'
                    ];
                }

                usleep(self::SCAN_DELAY * 1000);
            }
        }

        return [
            'vulnerabilities' => $vulnerabilities,
            'tests_run' => $testsRun
        ];
    }

    /**
     * CSRF protection scanning
     */
    private function scanCsrfProtection(array $targets, array $options): array
    {
        $vulnerabilities = [];
        $testsRun = 0;

        foreach ($targets as $target) {
            if (!$this->isStateChangingEndpoint($target)) {
                continue;
            }

            $testsRun++;

            // Test CSRF protection by sending request without token
            $response = $this->sendTestRequest($target, ['action' => 'test'], [], false);
            
            if ($this->detectCsrfVulnerability($response)) {
                $vulnerabilities[] = [
                    'type' => 'CSRF',
                    'target' => $target,
                    'risk_level' => self::RISK_HIGH,
                    'description' => 'Missing CSRF protection on state-changing endpoint',
                    'evidence' => 'Request succeeded without CSRF token',
                    'recommendation' => 'Implement CSRF tokens for all state-changing operations',
                    'cwe_id' => 'CWE-352'
                ];
            }

            usleep(self::SCAN_DELAY * 1000);
        }

        return [
            'vulnerabilities' => $vulnerabilities,
            'tests_run' => $testsRun
        ];
    }

    /**
     * Authentication flaw scanning
     */
    private function scanAuthenticationFlaws(array $targets, array $options): array
    {
        $vulnerabilities = [];
        $testsRun = 0;

        $authTests = [
            'weak_passwords' => $this->testWeakPasswords($targets),
            'brute_force_protection' => $this->testBruteForceProtection($targets),
            'session_fixation' => $this->testSessionFixation($targets),
            'password_reset_flaws' => $this->testPasswordResetFlaws($targets)
        ];

        foreach ($authTests as $testName => $testResults) {
            $testsRun += $testResults['tests_run'];
            $vulnerabilities = array_merge($vulnerabilities, $testResults['vulnerabilities']);
        }

        return [
            'vulnerabilities' => $vulnerabilities,
            'tests_run' => $testsRun
        ];
    }

    /**
     * Authorization bypass scanning
     */
    private function scanAuthorizationBypass(array $targets, array $options): array
    {
        $vulnerabilities = [];
        $testsRun = 0;

        foreach ($targets as $target) {
            if (!$this->isProtectedEndpoint($target)) {
                continue;
            }

            $tests = [
                'direct_access' => $this->testDirectAccess($target),
                'privilege_escalation' => $this->testPrivilegeEscalation($target),
                'idor' => $this->testInsecureDirectObjectReference($target)
            ];

            foreach ($tests as $testName => $result) {
                $testsRun++;
                if ($result['vulnerable']) {
                    $vulnerabilities[] = [
                        'type' => 'AUTHORIZATION_BYPASS',
                        'subtype' => strtoupper($testName),
                        'target' => $target,
                        'risk_level' => $result['risk_level'],
                        'description' => $result['description'],
                        'evidence' => $result['evidence'],
                        'recommendation' => $result['recommendation'],
                        'cwe_id' => $result['cwe_id']
                    ];
                }
            }
        }

        return [
            'vulnerabilities' => $vulnerabilities,
            'tests_run' => $testsRun
        ];
    }

    /**
     * Security headers scanning
     */
    private function scanSecurityHeaders(array $targets, array $options): array
    {
        $vulnerabilities = [];
        $testsRun = 0;

        $requiredHeaders = [
            'X-Frame-Options' => 'Missing clickjacking protection',
            'X-Content-Type-Options' => 'Missing MIME sniffing protection',
            'X-XSS-Protection' => 'Missing XSS protection header',
            'Strict-Transport-Security' => 'Missing HTTPS enforcement',
            'Content-Security-Policy' => 'Missing content security policy',
            'Referrer-Policy' => 'Missing referrer policy'
        ];

        foreach ($targets as $target) {
            $testsRun++;
            $response = $this->sendTestRequest($target);
            $headers = $response['headers'] ?? [];

            foreach ($requiredHeaders as $header => $description) {
                if (!$this->hasSecurityHeader($headers, $header)) {
                    $vulnerabilities[] = [
                        'type' => 'MISSING_SECURITY_HEADER',
                        'target' => $target,
                        'header' => $header,
                        'risk_level' => $this->getHeaderRiskLevel($header),
                        'description' => $description,
                        'recommendation' => "Add {$header} security header",
                        'cwe_id' => 'CWE-693'
                    ];
                }
            }
        }

        return [
            'vulnerabilities' => $vulnerabilities,
            'tests_run' => $testsRun
        ];
    }

    /**
     * Sensitive data exposure scanning
     */
    private function scanSensitiveDataExposure(array $targets, array $options): array
    {
        $vulnerabilities = [];
        $testsRun = 0;

        $sensitivePatterns = [
            'email' => '/[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/',
            'phone' => '/\b\d{3}[-.]?\d{3}[-.]?\d{4}\b/',
            'ssn' => '/\b\d{3}-\d{2}-\d{4}\b/',
            'credit_card' => '/\b\d{4}[-\s]?\d{4}[-\s]?\d{4}[-\s]?\d{4}\b/',
            'api_key' => '/[a-zA-Z0-9]{32,}/',
            'password' => '/password["\'\s]*[:=]["\'\s]*[^"\'\\s]+/i'
        ];

        foreach ($targets as $target) {
            $testsRun++;
            $response = $this->sendTestRequest($target);
            $content = $response['body'] ?? '';

            foreach ($sensitivePatterns as $type => $pattern) {
                if (preg_match($pattern, $content, $matches)) {
                    $vulnerabilities[] = [
                        'type' => 'SENSITIVE_DATA_EXPOSURE',
                        'subtype' => strtoupper($type),
                        'target' => $target,
                        'risk_level' => $this->getSensitiveDataRiskLevel($type),
                        'description' => "Potential {$type} exposure detected",
                        'evidence' => $this->maskSensitiveData($matches[0]),
                        'recommendation' => 'Remove or properly protect sensitive data',
                        'cwe_id' => 'CWE-200'
                    ];
                }
            }
        }

        return [
            'vulnerabilities' => $vulnerabilities,
            'tests_run' => $testsRun
        ];
    }

    /**
     * File upload vulnerability scanning
     */
    private function scanFileUploadFlaws(array $targets, array $options): array
    {
        $vulnerabilities = [];
        $testsRun = 0;

        $maliciousFiles = [
            'shell.php' => '<?php system($_GET["cmd"]); ?>',
            'script.jsp' => '<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>',
            'test.exe' => 'MZ executable header...',
        ];

        foreach ($targets as $target) {
            if (!$this->isFileUploadEndpoint($target)) {
                continue;
            }

            foreach ($maliciousFiles as $filename => $content) {
                $testsRun++;
                
                $response = $this->sendFileUploadTest($target, $filename, $content);
                
                if ($this->detectFileUploadVulnerability($response, $filename)) {
                    $vulnerabilities[] = [
                        'type' => 'FILE_UPLOAD_VULNERABILITY',
                        'target' => $target,
                        'filename' => $filename,
                        'risk_level' => self::RISK_CRITICAL,
                        'description' => 'Unrestricted file upload vulnerability',
                        'evidence' => 'Malicious file was uploaded successfully',
                        'recommendation' => 'Implement file type validation and sandboxing',
                        'cwe_id' => 'CWE-434'
                    ];
                }
            }
        }

        return [
            'vulnerabilities' => $vulnerabilities,
            'tests_run' => $testsRun
        ];
    }

    /**
     * Server configuration scanning
     */
    private function scanServerConfiguration(array $targets, array $options): array
    {
        $vulnerabilities = [];
        $testsRun = 1;

        // Check for information disclosure
        $infoDisclosureTests = [
            '/.git/config' => 'Git configuration exposed',
            '/.env' => 'Environment file exposed',
            '/phpinfo.php' => 'PHP info page exposed',
            '/server-status' => 'Server status page exposed',
            '/server-info' => 'Server info page exposed'
        ];

        foreach ($infoDisclosureTests as $path => $description) {
            $response = $this->sendTestRequest($path);
            if ($response['status_code'] === 200) {
                $vulnerabilities[] = [
                    'type' => 'INFORMATION_DISCLOSURE',
                    'target' => $path,
                    'risk_level' => self::RISK_MEDIUM,
                    'description' => $description,
                    'recommendation' => 'Remove or restrict access to sensitive files',
                    'cwe_id' => 'CWE-200'
                ];
            }
        }

        return [
            'vulnerabilities' => $vulnerabilities,
            'tests_run' => $testsRun
        ];
    }

    /**
     * Dependency vulnerability scanning
     */
    private function scanDependencyVulnerabilities(array $options): array
    {
        $vulnerabilities = [];
        $testsRun = 1;

        try {
            // Check composer.lock for known vulnerabilities
            $composerLock = $this->readComposerLock();
            if ($composerLock) {
                $knownVulns = $this->checkKnownVulnerabilities($composerLock);
                $vulnerabilities = array_merge($vulnerabilities, $knownVulns);
            }

        } catch (\Exception $e) {
            $this->logger->logError('Dependency scan error', ['error' => $e->getMessage()]);
        }

        return [
            'vulnerabilities' => $vulnerabilities,
            'tests_run' => $testsRun
        ];
    }

    // Helper methods for vulnerability detection

    private function generateScanId(): string
    {
        return 'scan_' . date('Y-m-d_H-i-s') . '_' . bin2hex(random_bytes(4));
    }

    private function getDefaultScanTargets(): array
    {
        return [
            '/',
            '/auth/login',
            '/auth/signup',
            '/stories',
            '/api/v1/stories',
            '/api/v1/users'
        ];
    }

    private function sendTestRequest(string $target, array $data = [], array $headers = [], bool $includeCsrf = true): array
    {
        // Mock implementation - would send actual HTTP requests in real implementation
        return [
            'status_code' => 200,
            'headers' => ['Content-Type' => 'text/html'],
            'body' => '<html><body>Test response</body></html>',
            'response_time' => 0.1
        ];
    }

    private function detectSqlInjectionVulnerability(array $response, string $payload): bool
    {
        $sqlErrorPatterns = [
            'mysql_fetch_array',
            'ORA-01756',
            'Microsoft OLE DB Provider',
            'PostgreSQL query failed',
            'SQLite error'
        ];

        $body = $response['body'] ?? '';
        foreach ($sqlErrorPatterns as $pattern) {
            if (stripos($body, $pattern) !== false) {
                return true;
            }
        }

        return false;
    }

    private function detectXssVulnerability(array $response, string $payload): bool
    {
        $body = $response['body'] ?? '';
        return strpos($body, $payload) !== false;
    }

    private function detectCsrfVulnerability(array $response): bool
    {
        return $response['status_code'] === 200;
    }

    private function storeScanResults(string $scanId, array $results): void
    {
        $this->cache->set("vuln_scan:{$scanId}", $results, 86400 * 7); // 7 days
    }

    private function isFormEndpoint(string $target): bool
    {
        return true; // Simplified for demo
    }

    private function isStateChangingEndpoint(string $target): bool
    {
        return true; // Simplified for demo
    }

    private function isProtectedEndpoint(string $target): bool
    {
        return true; // Simplified for demo
    }

    private function isFileUploadEndpoint(string $target): bool
    {
        return strpos($target, 'upload') !== false;
    }

    private function extractSqlInjectionEvidence(array $response): string
    {
        return 'SQL error detected in response';
    }

    private function extractXssEvidence(array $response): string
    {
        return 'XSS payload reflected in response';
    }

    private function determineXssRiskLevel(string $target, string $payload): string
    {
        return self::RISK_HIGH;
    }

    private function hasSecurityHeader(array $headers, string $header): bool
    {
        return isset($headers[$header]);
    }

    private function getHeaderRiskLevel(string $header): string
    {
        return match($header) {
            'Content-Security-Policy' => self::RISK_HIGH,
            'Strict-Transport-Security' => self::RISK_HIGH,
            default => self::RISK_MEDIUM
        };
    }

    private function getSensitiveDataRiskLevel(string $type): string
    {
        return match($type) {
            'password', 'api_key' => self::RISK_CRITICAL,
            'ssn', 'credit_card' => self::RISK_HIGH,
            default => self::RISK_MEDIUM
        };
    }

    private function maskSensitiveData(string $data): string
    {
        return substr($data, 0, 3) . str_repeat('*', max(0, strlen($data) - 6)) . substr($data, -3);
    }

    // Additional test methods would be implemented here...
    private function testWeakPasswords(array $targets): array { return ['vulnerabilities' => [], 'tests_run' => 0]; }
    private function testBruteForceProtection(array $targets): array { return ['vulnerabilities' => [], 'tests_run' => 0]; }
    private function testSessionFixation(array $targets): array { return ['vulnerabilities' => [], 'tests_run' => 0]; }
    private function testPasswordResetFlaws(array $targets): array { return ['vulnerabilities' => [], 'tests_run' => 0]; }
    private function testDirectAccess(string $target): array { return ['vulnerable' => false]; }
    private function testPrivilegeEscalation(string $target): array { return ['vulnerable' => false]; }
    private function testInsecureDirectObjectReference(string $target): array { return ['vulnerable' => false]; }
    private function sendFileUploadTest(string $target, string $filename, string $content): array { return ['status_code' => 403]; }
    private function detectFileUploadVulnerability(array $response, string $filename): bool { return false; }
    private function readComposerLock(): ?array { return null; }
    private function checkKnownVulnerabilities(array $composerLock): array { return []; }
}